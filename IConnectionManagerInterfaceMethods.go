// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/bhbosman/goConnectionManager (interfaces: IConnectionManager)

// Package goConnectionManager is a generated GoMock package.
package goConnectionManager

import (
	context "context"
	fmt "fmt"

	errors "github.com/bhbosman/gocommon/errors"
	model "github.com/bhbosman/gocommon/model"
)

// Interface A Comment
// Interface github.com/bhbosman/goConnectionManager
// Interface IConnectionManager
// Interface IConnectionManager, Method: CloseAllConnections
type IConnectionManagerCloseAllConnectionsIn struct {
	arg0 context.Context
}

type IConnectionManagerCloseAllConnectionsOut struct {
	Args0 error
}
type IConnectionManagerCloseAllConnectionsError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionManagerCloseAllConnectionsError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionManagerCloseAllConnections struct {
	inData         IConnectionManagerCloseAllConnectionsIn
	outDataChannel chan IConnectionManagerCloseAllConnectionsOut
}

func NewIConnectionManagerCloseAllConnections(waitToComplete bool, arg0 context.Context) *IConnectionManagerCloseAllConnections {
	var outDataChannel chan IConnectionManagerCloseAllConnectionsOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionManagerCloseAllConnectionsOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionManagerCloseAllConnections{
		inData: IConnectionManagerCloseAllConnectionsIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionManagerCloseAllConnections) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionManagerCloseAllConnectionsOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionManagerCloseAllConnectionsError{
			InterfaceName: "IConnectionManager",
			MethodName:    "CloseAllConnections",
			Reason:        "Channel for IConnectionManager::CloseAllConnections returned false",
		}
		if onError != nil {
			err := onError("IConnectionManager", "CloseAllConnections", generatedError)
			return IConnectionManagerCloseAllConnectionsOut{}, err
		} else {
			return IConnectionManagerCloseAllConnectionsOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionManagerCloseAllConnections) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionManagerCloseAllConnections(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 context.Context) (IConnectionManagerCloseAllConnectionsOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionManagerCloseAllConnectionsOut{}, context.Err()
	}
	data := NewIConnectionManagerCloseAllConnections(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IConnectionManagerCloseAllConnections) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionManagerCloseAllConnectionsOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionManagerCloseAllConnectionsOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionManagerCloseAllConnectionsOut{}, err
	}
	return v, nil
}

// Interface IConnectionManager, Method: CloseConnection
type IConnectionManagerCloseConnectionIn struct {
	arg0 string
}

type IConnectionManagerCloseConnectionOut struct {
	Args0 error
}
type IConnectionManagerCloseConnectionError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionManagerCloseConnectionError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionManagerCloseConnection struct {
	inData         IConnectionManagerCloseConnectionIn
	outDataChannel chan IConnectionManagerCloseConnectionOut
}

func NewIConnectionManagerCloseConnection(waitToComplete bool, arg0 string) *IConnectionManagerCloseConnection {
	var outDataChannel chan IConnectionManagerCloseConnectionOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionManagerCloseConnectionOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionManagerCloseConnection{
		inData: IConnectionManagerCloseConnectionIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionManagerCloseConnection) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionManagerCloseConnectionOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionManagerCloseConnectionError{
			InterfaceName: "IConnectionManager",
			MethodName:    "CloseConnection",
			Reason:        "Channel for IConnectionManager::CloseConnection returned false",
		}
		if onError != nil {
			err := onError("IConnectionManager", "CloseConnection", generatedError)
			return IConnectionManagerCloseConnectionOut{}, err
		} else {
			return IConnectionManagerCloseConnectionOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionManagerCloseConnection) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionManagerCloseConnection(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 string) (IConnectionManagerCloseConnectionOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionManagerCloseConnectionOut{}, context.Err()
	}
	data := NewIConnectionManagerCloseConnection(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IConnectionManagerCloseConnection) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionManagerCloseConnectionOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionManagerCloseConnectionOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionManagerCloseConnectionOut{}, err
	}
	return v, nil
}

// Interface IConnectionManager, Method: ConnectionInformationReceived
type IConnectionManagerConnectionInformationReceivedIn struct {
	arg0 *model.PublishRxHandlerCounters
}

type IConnectionManagerConnectionInformationReceivedOut struct {
	Args0 error
}
type IConnectionManagerConnectionInformationReceivedError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionManagerConnectionInformationReceivedError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionManagerConnectionInformationReceived struct {
	inData         IConnectionManagerConnectionInformationReceivedIn
	outDataChannel chan IConnectionManagerConnectionInformationReceivedOut
}

func NewIConnectionManagerConnectionInformationReceived(waitToComplete bool, arg0 *model.PublishRxHandlerCounters) *IConnectionManagerConnectionInformationReceived {
	var outDataChannel chan IConnectionManagerConnectionInformationReceivedOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionManagerConnectionInformationReceivedOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionManagerConnectionInformationReceived{
		inData: IConnectionManagerConnectionInformationReceivedIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionManagerConnectionInformationReceived) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionManagerConnectionInformationReceivedOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionManagerConnectionInformationReceivedError{
			InterfaceName: "IConnectionManager",
			MethodName:    "ConnectionInformationReceived",
			Reason:        "Channel for IConnectionManager::ConnectionInformationReceived returned false",
		}
		if onError != nil {
			err := onError("IConnectionManager", "ConnectionInformationReceived", generatedError)
			return IConnectionManagerConnectionInformationReceivedOut{}, err
		} else {
			return IConnectionManagerConnectionInformationReceivedOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionManagerConnectionInformationReceived) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionManagerConnectionInformationReceived(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 *model.PublishRxHandlerCounters) (IConnectionManagerConnectionInformationReceivedOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionManagerConnectionInformationReceivedOut{}, context.Err()
	}
	data := NewIConnectionManagerConnectionInformationReceived(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IConnectionManagerConnectionInformationReceived) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionManagerConnectionInformationReceivedOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionManagerConnectionInformationReceivedOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionManagerConnectionInformationReceivedOut{}, err
	}
	return v, nil
}

// Interface IConnectionManager, Method: DeregisterConnection
type IConnectionManagerDeregisterConnectionIn struct {
	arg0 string
}

type IConnectionManagerDeregisterConnectionOut struct {
	Args0 error
}
type IConnectionManagerDeregisterConnectionError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionManagerDeregisterConnectionError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionManagerDeregisterConnection struct {
	inData         IConnectionManagerDeregisterConnectionIn
	outDataChannel chan IConnectionManagerDeregisterConnectionOut
}

func NewIConnectionManagerDeregisterConnection(waitToComplete bool, arg0 string) *IConnectionManagerDeregisterConnection {
	var outDataChannel chan IConnectionManagerDeregisterConnectionOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionManagerDeregisterConnectionOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionManagerDeregisterConnection{
		inData: IConnectionManagerDeregisterConnectionIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionManagerDeregisterConnection) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionManagerDeregisterConnectionOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionManagerDeregisterConnectionError{
			InterfaceName: "IConnectionManager",
			MethodName:    "DeregisterConnection",
			Reason:        "Channel for IConnectionManager::DeregisterConnection returned false",
		}
		if onError != nil {
			err := onError("IConnectionManager", "DeregisterConnection", generatedError)
			return IConnectionManagerDeregisterConnectionOut{}, err
		} else {
			return IConnectionManagerDeregisterConnectionOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionManagerDeregisterConnection) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionManagerDeregisterConnection(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 string) (IConnectionManagerDeregisterConnectionOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionManagerDeregisterConnectionOut{}, context.Err()
	}
	data := NewIConnectionManagerDeregisterConnection(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IConnectionManagerDeregisterConnection) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionManagerDeregisterConnectionOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionManagerDeregisterConnectionOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionManagerDeregisterConnectionOut{}, err
	}
	return v, nil
}

// Interface IConnectionManager, Method: GetConnections
type IConnectionManagerGetConnectionsIn struct {
	arg0 context.Context
}

type IConnectionManagerGetConnectionsOut struct {
	Args0 []*model.ConnectionInformation
	Args1 error
}
type IConnectionManagerGetConnectionsError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionManagerGetConnectionsError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionManagerGetConnections struct {
	inData         IConnectionManagerGetConnectionsIn
	outDataChannel chan IConnectionManagerGetConnectionsOut
}

func NewIConnectionManagerGetConnections(waitToComplete bool, arg0 context.Context) *IConnectionManagerGetConnections {
	var outDataChannel chan IConnectionManagerGetConnectionsOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionManagerGetConnectionsOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionManagerGetConnections{
		inData: IConnectionManagerGetConnectionsIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionManagerGetConnections) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionManagerGetConnectionsOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionManagerGetConnectionsError{
			InterfaceName: "IConnectionManager",
			MethodName:    "GetConnections",
			Reason:        "Channel for IConnectionManager::GetConnections returned false",
		}
		if onError != nil {
			err := onError("IConnectionManager", "GetConnections", generatedError)
			return IConnectionManagerGetConnectionsOut{}, err
		} else {
			return IConnectionManagerGetConnectionsOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionManagerGetConnections) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionManagerGetConnections(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 context.Context) (IConnectionManagerGetConnectionsOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionManagerGetConnectionsOut{}, context.Err()
	}
	data := NewIConnectionManagerGetConnections(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IConnectionManagerGetConnections) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionManagerGetConnectionsOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionManagerGetConnectionsOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionManagerGetConnectionsOut{}, err
	}
	return v, nil
}

// Interface IConnectionManager, Method: MultiSend
type IConnectionManagerMultiSendIn struct {
	arg0 []interface{}
}

type IConnectionManagerMultiSendOut struct {
}
type IConnectionManagerMultiSendError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionManagerMultiSendError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionManagerMultiSend struct {
	inData         IConnectionManagerMultiSendIn
	outDataChannel chan IConnectionManagerMultiSendOut
}

func NewIConnectionManagerMultiSend(waitToComplete bool, arg0 ...interface{}) *IConnectionManagerMultiSend {
	var outDataChannel chan IConnectionManagerMultiSendOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionManagerMultiSendOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionManagerMultiSend{
		inData: IConnectionManagerMultiSendIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionManagerMultiSend) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionManagerMultiSendOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionManagerMultiSendError{
			InterfaceName: "IConnectionManager",
			MethodName:    "MultiSend",
			Reason:        "Channel for IConnectionManager::MultiSend returned false",
		}
		if onError != nil {
			err := onError("IConnectionManager", "MultiSend", generatedError)
			return IConnectionManagerMultiSendOut{}, err
		} else {
			return IConnectionManagerMultiSendOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionManagerMultiSend) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionManagerMultiSend(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 ...interface{}) (IConnectionManagerMultiSendOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionManagerMultiSendOut{}, context.Err()
	}
	data := NewIConnectionManagerMultiSend(waitToComplete, arg0...)
	if waitToComplete {
		defer func(data *IConnectionManagerMultiSend) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionManagerMultiSendOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionManagerMultiSendOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionManagerMultiSendOut{}, err
	}
	return v, nil
}

// Interface IConnectionManager, Method: NameConnection
type IConnectionManagerNameConnectionIn struct {
	arg0 string
	arg1 string
}

type IConnectionManagerNameConnectionOut struct {
	Args0 error
}
type IConnectionManagerNameConnectionError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionManagerNameConnectionError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionManagerNameConnection struct {
	inData         IConnectionManagerNameConnectionIn
	outDataChannel chan IConnectionManagerNameConnectionOut
}

func NewIConnectionManagerNameConnection(waitToComplete bool, arg0, arg1 string) *IConnectionManagerNameConnection {
	var outDataChannel chan IConnectionManagerNameConnectionOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionManagerNameConnectionOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionManagerNameConnection{
		inData: IConnectionManagerNameConnectionIn{
			arg0: arg0,
			arg1: arg1,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionManagerNameConnection) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionManagerNameConnectionOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionManagerNameConnectionError{
			InterfaceName: "IConnectionManager",
			MethodName:    "NameConnection",
			Reason:        "Channel for IConnectionManager::NameConnection returned false",
		}
		if onError != nil {
			err := onError("IConnectionManager", "NameConnection", generatedError)
			return IConnectionManagerNameConnectionOut{}, err
		} else {
			return IConnectionManagerNameConnectionOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionManagerNameConnection) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionManagerNameConnection(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0, arg1 string) (IConnectionManagerNameConnectionOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionManagerNameConnectionOut{}, context.Err()
	}
	data := NewIConnectionManagerNameConnection(waitToComplete, arg0, arg1)
	if waitToComplete {
		defer func(data *IConnectionManagerNameConnection) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionManagerNameConnectionOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionManagerNameConnectionOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionManagerNameConnectionOut{}, err
	}
	return v, nil
}

// Interface IConnectionManager, Method: RegisterConnection
type IConnectionManagerRegisterConnectionIn struct {
	arg0 string
	arg1 context.CancelFunc
	arg2 context.Context
}

type IConnectionManagerRegisterConnectionOut struct {
	Args0 error
}
type IConnectionManagerRegisterConnectionError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionManagerRegisterConnectionError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionManagerRegisterConnection struct {
	inData         IConnectionManagerRegisterConnectionIn
	outDataChannel chan IConnectionManagerRegisterConnectionOut
}

func NewIConnectionManagerRegisterConnection(waitToComplete bool, arg0 string, arg1 context.CancelFunc, arg2 context.Context) *IConnectionManagerRegisterConnection {
	var outDataChannel chan IConnectionManagerRegisterConnectionOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionManagerRegisterConnectionOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionManagerRegisterConnection{
		inData: IConnectionManagerRegisterConnectionIn{
			arg0: arg0,
			arg1: arg1,
			arg2: arg2,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionManagerRegisterConnection) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionManagerRegisterConnectionOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionManagerRegisterConnectionError{
			InterfaceName: "IConnectionManager",
			MethodName:    "RegisterConnection",
			Reason:        "Channel for IConnectionManager::RegisterConnection returned false",
		}
		if onError != nil {
			err := onError("IConnectionManager", "RegisterConnection", generatedError)
			return IConnectionManagerRegisterConnectionOut{}, err
		} else {
			return IConnectionManagerRegisterConnectionOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionManagerRegisterConnection) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionManagerRegisterConnection(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 string, arg1 context.CancelFunc, arg2 context.Context) (IConnectionManagerRegisterConnectionOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionManagerRegisterConnectionOut{}, context.Err()
	}
	data := NewIConnectionManagerRegisterConnection(waitToComplete, arg0, arg1, arg2)
	if waitToComplete {
		defer func(data *IConnectionManagerRegisterConnection) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionManagerRegisterConnectionOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionManagerRegisterConnectionOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionManagerRegisterConnectionOut{}, err
	}
	return v, nil
}

// Interface IConnectionManager, Method: Send
type IConnectionManagerSendIn struct {
	arg0 interface{}
}

type IConnectionManagerSendOut struct {
	Args0 error
}
type IConnectionManagerSendError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionManagerSendError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionManagerSend struct {
	inData         IConnectionManagerSendIn
	outDataChannel chan IConnectionManagerSendOut
}

func NewIConnectionManagerSend(waitToComplete bool, arg0 interface{}) *IConnectionManagerSend {
	var outDataChannel chan IConnectionManagerSendOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionManagerSendOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionManagerSend{
		inData: IConnectionManagerSendIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionManagerSend) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionManagerSendOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionManagerSendError{
			InterfaceName: "IConnectionManager",
			MethodName:    "Send",
			Reason:        "Channel for IConnectionManager::Send returned false",
		}
		if onError != nil {
			err := onError("IConnectionManager", "Send", generatedError)
			return IConnectionManagerSendOut{}, err
		} else {
			return IConnectionManagerSendOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionManagerSend) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionManagerSend(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 interface{}) (IConnectionManagerSendOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionManagerSendOut{}, context.Err()
	}
	data := NewIConnectionManagerSend(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IConnectionManagerSend) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionManagerSendOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionManagerSendOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionManagerSendOut{}, err
	}
	return v, nil
}

func ChannelEventsForIConnectionManager(next IConnectionManager, event interface{}) (bool, error) {
	switch v := event.(type) {
	case *IConnectionManagerCloseAllConnections:
		data := IConnectionManagerCloseAllConnectionsOut{}
		data.Args0 = next.CloseAllConnections(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IConnectionManagerCloseConnection:
		data := IConnectionManagerCloseConnectionOut{}
		data.Args0 = next.CloseConnection(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IConnectionManagerConnectionInformationReceived:
		data := IConnectionManagerConnectionInformationReceivedOut{}
		data.Args0 = next.ConnectionInformationReceived(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IConnectionManagerDeregisterConnection:
		data := IConnectionManagerDeregisterConnectionOut{}
		data.Args0 = next.DeregisterConnection(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IConnectionManagerGetConnections:
		data := IConnectionManagerGetConnectionsOut{}
		data.Args0, data.Args1 = next.GetConnections(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IConnectionManagerMultiSend:
		data := IConnectionManagerMultiSendOut{}
		next.MultiSend(v.inData.arg0...)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IConnectionManagerNameConnection:
		data := IConnectionManagerNameConnectionOut{}
		data.Args0 = next.NameConnection(v.inData.arg0, v.inData.arg1)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IConnectionManagerRegisterConnection:
		data := IConnectionManagerRegisterConnectionOut{}
		data.Args0 = next.RegisterConnection(v.inData.arg0, v.inData.arg1, v.inData.arg2)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IConnectionManagerSend:
		data := IConnectionManagerSendOut{}
		data.Args0 = next.Send(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	default:
		return false, nil
	}
}
